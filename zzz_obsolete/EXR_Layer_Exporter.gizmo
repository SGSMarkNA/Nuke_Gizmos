#! C:/Program Files/Nuke9.0v7/nuke-9.0.7.dll -nx
#write_info Write_EXR file:"" format:"4000 4000 1" chans:":rgba.red:rgba.green:rgba.blue:rgba.alpha:AMB.blue:AMB.green:AMB.red:bumpnormals.X:bumpnormals.Y:bumpnormals.Z:diffuse.blue:diffuse.green:diffuse.red:normals.X:normals.Y:normals.Z:reflect.blue:reflect.green:reflect.red:refract.blue:refract.green:refract.red:specular.blue:specular.green:specular.red:totalLight.blue:totalLight.green:totalLight.red:" framerange:"1 1" fps:"0" colorspace:"default (linear)" datatype:"16 bit half" transfer:"unknown" views:"main"
version 9.0 v7
Gizmo {
 addUserKnob {20 User}
 addUserKnob {26 ""}
 addUserKnob {26 step_one l "1) Check for EXR Layers:" -STARTLINE}
 addUserKnob {22 check_for_layers l Update -STARTLINE T "##--------------------------------------------\nimport re\n##--------------------------------------------\n## Check for Layers Python button...\nGroupNode = nuke.thisNode()\n# Select the input Read node...\ntry:\n    ConnectedNode = GroupNode.input(0)\n    # Sanity check that we've got a Read node connected to the input...\n    if not ConnectedNode.Class() == 'Read':\n        nuke.message(\"Please connect a Read node to the input.(01)\")    \nexcept AttributeError:\n    nuke.message(\"Attribute Error: Please connect a Read node to the input.(02)\")\n\n############################################################################################\n##                 LAYERS DETECTION\n############################################################################################\n##--------------------------------------------\n## Get all the layers and channels contained in an EXR image file and put them into a layers list...\ntry:\n    if ConnectedNode:\n        channels = ConnectedNode.channels()\n        layers = list(set(\[c.split('.')\[0] for c in channels]))\n        layers.sort()\nexcept NameError:\n    nuke.message(\"Name Error: No image channels found.(04)\")\n\n############################################################################################\n##                 KNOB REMOVALS\n############################################################################################\n##--------------------------------------------\n## Get the knobs and set up some categories...\nGroupNodeKnobs = GroupNode.allKnobs()\nknobs_to_remove = \[]\nknobs_to_ignore = \['selected', 'hide_input', 'cached', 'dope_sheet', 'bookmark', 'postage_stamp', 'useLifetime', 'lock_connections']\n##--------------------------------------------\n## Remove any existing Boolean_Knob (checkbox) instances...\nregex = re.compile(r\"\\WBoolean_Knob\\W\")   ## \\W is anything but a word character...\nfor knob in GroupNodeKnobs:\n    if bool(regex.search(str(type(knob)))):\n        if knob.name() not in knobs_to_ignore:\n            name = knob.name()\n            knobs_to_remove.append(name)\n        else:\n            pass\n# Remove old checkbox knobs (Boolean_Knob) when the Update button is pressed, before we make some new ones...\nKnobs = GroupNode.knobs()\ntry:\n    for knobname in knobs_to_remove:\n        GroupNode.removeKnob(Knobs\[knobname])\nexcept KeyError:\n    print 'Key Error: Some knobs could not be removed!\[01]'\nexcept ValueError:\n    print 'Value Error: Some knobs could not be removed!\[02]'\n# Also delete the additional knobs, so they don't multiply like rabbits...\ntry:\n    GroupNode.removeKnob(Knobs\['select_all'])\n    GroupNode.removeKnob(Knobs\['invert_selection'])\n    GroupNode.removeKnob(Knobs\['newline'])\n    GroupNode.removeKnob(Knobs\['step_three'])\n    GroupNode.removeKnob(Knobs\['build_button'])\n    GroupNode.removeKnob(Knobs\['newline2'])\n    GroupNode.removeKnob(Knobs\['step_four'])\n    # Remove the knobs from the \"Write_EXR\" node that always stays in the group...  \n    GroupNode.removeKnob(Knobs\['file'])\n    GroupNode.removeKnob(Knobs\['Render'])\nexcept KeyError:\n    print 'Key Error: Some knobs could not be removed!\[03]'\nexcept ValueError:\n    print 'Value Error: Some knobs could not be removed!\[04]'\n\n############################################################################################\n##             NODE REMOVALS\n############################################################################################\n##--------------------------------------------  \n## Remove any existing group nodes...\nAllNodes = \[node for node in GroupNode.nodes()]\ntry:\n    for Node in AllNodes:\n        if Node.Class()==('Crop'):\n            nuke.delete(Node)\n        elif Node.Class()==('Remove'):\n            nuke.delete(Node)      \nexcept ValueError:\n    print 'Value Error: Got an error...\[05]'\n\n############################################################################################\n##             ADD KNOBS\n############################################################################################\n\n\n##--------------------------------------------\n## Knobs to add...\n#topline_knob = nuke.Text_Knob('topline', '')\n#GroupNode.addKnob(topline_knob)\n## Step 3\n#step_one_knob = nuke.Text_Knob('step_one', '1) Check for EXR Layers:')\n#GroupNode.addKnob(step_one_knob)\n\n\n##--------------------------------------------\n## Add knobs for Select All and Invert Selection...\n# Select All button...\nselect_all_button = nuke.PyScript_Knob('select_all', 'Select All', '''\nfor knob in checkboxKnobs:\n    knob.setValue(True)\n''')\nGroupNode.addKnob(select_all_button)\nselect_all_button.setFlag(nuke.STARTLINE)\n\n# Invert Selection button...\ninvert_selection_button = nuke.PyScript_Knob('invert_selection', 'Invert Selection', '''\ndef invertSelection():\n    for checkbox in checkboxKnobs:\n        if checkbox.value():\n            checkbox.setValue(False)\n        else:\n            checkbox.setValue(True)\n##############################################################    \ninvertSelection()\n''')\nGroupNode.addKnob(invert_selection_button)\n##--------------------------------------------\n## Add new checkbox knobs, based on the layers found in the input Read node...\ncheckboxKnobs = \[]\ntry:\n    if layers:\n        for layer in layers:\n            Knob_string = 'nuke.' + 'Boolean_Knob' + '(' + \"'\" + layer + \"'\" + ', ' + \"'\" + layer + \"'\" + ')'\n            Knob = eval(Knob_string)\n            GroupNode.addKnob(Knob)\n            Knob.setFlag(nuke.STARTLINE)\n            checkboxKnobs.append(Knob)\nexcept NameError:\n    nuke.message(\"Name Error: No image channels found.(05)\")\n##--------------------------------------------\n## More knobs to add...\nnewline_knob = nuke.Text_Knob('newline', '')\nGroupNode.addKnob(newline_knob)\n# Step 3\nstep_three_knob = nuke.Text_Knob('step_three', '3) Build the Layers:')\nGroupNode.addKnob(step_three_knob)\n\n############################################################################################\n##             ADD NODES\n############################################################################################\n##--------------------------------------------\n## Make a PyScript button to do all the node building stuff...\nBuildButton = nuke.PyScript_Knob('build_button', 'Assemble', '''\ndef Doit():\n\n    GroupNode = nuke.thisNode()\n\n    ##############################################################\n\n    # Remove existing internal group nodes...\n    AllNodes = \[node for node in GroupNode.nodes()]\n    try:\n        for Node in AllNodes:\n            if Node.Class()==('Crop'):\n                nuke.delete(Node)\n            elif Node.Class()==('Remove'):\n                nuke.delete(Node)\n    except ValueError:\n        print 'Value Error: Some non-existant nodes could not be removed. Not a problem...\[06]'\n\n    ##############################################################\n\n    checkboxesDict = \{\}\n    layers_to_export = \[]\n    layers_to_remove = \[]\n    for checkbox in checkboxKnobs:\n        checkbox_value = checkbox.value()\n        checkboxesDict\[checkbox.name()] = checkbox_value\n    for knobname, value in checkboxesDict.iteritems():\n        if value == True:\n            layers_to_export.append(knobname)\n    if not layers_to_export:\n        nuke.message('Please select layers for export.(06)')\n        return\n    else:\n        for layer in layers:\n            if layer not in layers_to_export:\n                layers_to_remove.append(layer)\n    print 'Layers to Export -->', layers_to_export\n    print 'Layers to Remove -->', layers_to_remove\n\n    ##############################################################\n\n    # Calculate how many Remove nodes we need -- only 4 layers can be removed per node...\n    # divmod returns a tuple with (quotient, remainder)...\n    num_of_nodes = divmod(len(layers_to_remove), 4)\n    if num_of_nodes\[1] is 0:\n        num_of_nodes = num_of_nodes\[0]\n    else:\n        # We need one additional node for the remainder...\n        num_of_nodes = num_of_nodes\[0] + 1\n\n    # We've only got a maximum of four channel removal knobs available on a Remove node...\n    removal_knobs = \['channels', 'channels2', 'channels3', 'channels4']\n\n    # Select the Input node, so the new nodes get attached after that...\n    InputNode = nuke.toNode('Input1')\n    InputNode.knob(\"selected\").setValue(True)\n\n    # Create Remove nodes, based on the number of layers to be removed...\n    for node in range(num_of_nodes):\n        RemoveNode = nuke.createNode(\"Remove\", inpanel = False)\n        for knobname in removal_knobs:\n            if layers_to_remove:\n                layer = layers_to_remove.pop()\n                RemoveNode\[knobname].setValue(layer)\n\n    ##############################################################\n\n    # Add a Crop node to make sure that Photoshop won't lose a pixel, based on the bounding box...\n    cropnode = nuke.createNode('Crop', inpanel = False)\n    cropnode.knob('label').setValue('PHOTOSHOP FIX.')\n    cropnode.knob('reformat').setValue(True)\n    cropnode.knob('crop').setValue(True)\n\n    ##############################################################\n##############################################################\nDoit()\n''')\n# Add the Build button knob...\nGroupNode.addKnob(BuildButton)\n##--------------------------------------------\nnewline_knob2 = nuke.Text_Knob('newline2', '')\nGroupNode.addKnob(newline_knob2)\n##--------------------------------------------\n# Step 4\nstep_four_knob = nuke.Text_Knob('step_four', '4) Save the EXR File:')\nGroupNode.addKnob(step_four_knob)\n##--------------------------------------------\n# Get the Write_EXR node's file knob and add it...\nWrite = nuke.toNode('Write_EXR')\nFileKnob = Write.knob('file')\nGroupNode.addKnob(FileKnob)\nFileKnob.setFlag(nuke.STARTLINE)\n# Get the Write_EXR node's Render button knob and add it...\nRenderButton = Write.knob('Render')\nGroupNode.addKnob(RenderButton)\nRenderButton.setFlag(nuke.STARTLINE)\n\n\n\n\n"}
 addUserKnob {26 ""}
 addUserKnob {26 step_two l "2) Select Layers for Export:"}
 addUserKnob {22 select_all l "Select All" T "\nfor knob in checkboxKnobs:\n    knob.setValue(True)\n" +STARTLINE}
 addUserKnob {22 invert_selection l "Invert Selection" -STARTLINE T "\ndef invertSelection():\n    for checkbox in checkboxKnobs:\n        if checkbox.value():\n            checkbox.setValue(False)\n        else:\n            checkbox.setValue(True)\n##############################################################    \ninvertSelection()\n"}
 addUserKnob {6 AMB +STARTLINE}
 addUserKnob {6 bumpnormals +STARTLINE}
 addUserKnob {6 diffuse +STARTLINE}
 addUserKnob {6 normals +STARTLINE}
 addUserKnob {6 reflect +STARTLINE}
 addUserKnob {6 refract +STARTLINE}
 addUserKnob {6 rgba +STARTLINE}
 addUserKnob {6 specular +STARTLINE}
 addUserKnob {6 totalLight +STARTLINE}
 addUserKnob {26 newline l "" +STARTLINE}
 addUserKnob {26 step_three l "3) Build the Layers:"}
 addUserKnob {22 build_button l Assemble -STARTLINE T "\ndef Doit():\n\n    GroupNode = nuke.thisNode()\n\n    ##############################################################\n\n    # Remove existing internal group nodes...\n    AllNodes = \[node for node in GroupNode.nodes()]\n    try:\n        for Node in AllNodes:\n            if Node.Class()==('Crop'):\n                nuke.delete(Node)\n            elif Node.Class()==('Remove'):\n                nuke.delete(Node)\n    except ValueError:\n        print 'Value Error: Some non-existant nodes could not be removed. Not a problem...\[06]'\n\n    ##############################################################\n\n    checkboxesDict = \{\}\n    layers_to_export = \[]\n    layers_to_remove = \[]\n    for checkbox in checkboxKnobs:\n        checkbox_value = checkbox.value()\n        checkboxesDict\[checkbox.name()] = checkbox_value\n    for knobname, value in checkboxesDict.iteritems():\n        if value == True:\n            layers_to_export.append(knobname)\n    if not layers_to_export:\n        nuke.message('Please select layers for export.(06)')\n        return\n    else:\n        for layer in layers:\n            if layer not in layers_to_export:\n                layers_to_remove.append(layer)\n    print 'Layers to Export -->', layers_to_export\n    print 'Layers to Remove -->', layers_to_remove\n\n    ##############################################################\n\n    # Calculate how many Remove nodes we need -- only 4 layers can be removed per node...\n    # divmod returns a tuple with (quotient, remainder)...\n    num_of_nodes = divmod(len(layers_to_remove), 4)\n    if num_of_nodes\[1] is 0:\n        num_of_nodes = num_of_nodes\[0]\n    else:\n        # We need one additional node for the remainder...\n        num_of_nodes = num_of_nodes\[0] + 1\n\n    # We've only got a maximum of four channel removal knobs available on a Remove node...\n    removal_knobs = \['channels', 'channels2', 'channels3', 'channels4']\n\n    # Select the Input node, so the new nodes get attached after that...\n    InputNode = nuke.toNode('Input1')\n    InputNode.knob(\"selected\").setValue(True)\n\n    # Create Remove nodes, based on the number of layers to be removed...\n    for node in range(num_of_nodes):\n        RemoveNode = nuke.createNode(\"Remove\", inpanel = False)\n        for knobname in removal_knobs:\n            if layers_to_remove:\n                layer = layers_to_remove.pop()\n                RemoveNode\[knobname].setValue(layer)\n\n    ##############################################################\n\n    # Add a Crop node to make sure that Photoshop won't lose a pixel, based on the bounding box...\n    cropnode = nuke.createNode('Crop', inpanel = False)\n    cropnode.knob('label').setValue('PHOTOSHOP FIX.')\n    cropnode.knob('reformat').setValue(True)\n    cropnode.knob('crop').setValue(True)\n\n    ##############################################################\n##############################################################\nDoit()\n"}
 addUserKnob {26 newline2 l "" +STARTLINE}
 addUserKnob {26 step_four l "4) Save the EXR File:"}
 addUserKnob {2 file}
 addUserKnob {22 Render t "Press this to render image files" T "nukescripts.render_panel((nuke.thisNode(),), False)" +STARTLINE}
}
 Input {
  inputs 0
  name Input1
  xpos 365
  ypos -573
 }
set Nb0146c00 [stack 0]
 Output {
  name Output1
  xpos 365
  ypos -81
 }
push $Nb0146c00
 Write {
  channels all
  file_type exr
  on_error black
  version 7
  name Write_EXR
  xpos 365
  ypos -153
 }
end_group
